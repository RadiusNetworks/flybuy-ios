// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.21 clang-1700.0.13.3)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name FlyBuyNotify
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1
import BackgroundTasks
import CoreLocation
import FlyBuy
@_exported import FlyBuyNotify
import Foundation
import Swift
import UIKit
import UserNotifications
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public enum SyncHistory {
  public static var writeToDefaultsEnabled: Swift.Bool
  public static func addEvent(_ description: Swift.String)
  public static func addBGTaskExpiredEvent()
  public static func addPushSyncAttemptEvent()
  public static func addPushSyncCompleteEvent(error: (any Swift.Error)?)
  public static func addBGFetchAttemptEvent()
  public static func addBGFetchCompleteEvent(error: (any Swift.Error)?)
  public static func appendHistory(_ str: Swift.String)
  public static func updateLastSync(_ date: Foundation.Date)
  public static func updateAppInstanceID()
  public static func appVersion() -> Swift.String
  public static func updateAppVersion()
}
open class Context {
  public init(dictionary: [Swift.String : FlyBuyNotify.Token.Value]? = nil)
  public init(dictionary: [Swift.String : Any?])
  open func getValue(for key: Swift.String) -> FlyBuyNotify.Token.Value?
  open func set(value: FlyBuyNotify.Token.Value, for key: Swift.String)
  open func set(value: Any?, for key: Swift.String)
  open func incrementCounter(for key: Swift.String) -> Swift.Int
  open func decrementCounter(for key: Swift.String) -> Swift.Int
  open func next(in group: [FlyBuyNotify.Token.Value], identifier: Swift.String?) -> FlyBuyNotify.Token.Value?
  @objc deinit
}
extension FlyBuyNotify.Context {
  public func makeSupplement(with variables: [Swift.String : FlyBuyNotify.Token.Value]) -> FlyBuyNotify.Context
}
public enum Token : Swift.Equatable {
  case text(value: Swift.String)
  case variable(value: Swift.String)
  case tag(value: Swift.String)
  public static func == (lhs: FlyBuyNotify.Token, rhs: FlyBuyNotify.Token) -> Swift.Bool
  indirect public enum Value : Swift.Hashable {
    case `nil`
    case bool(Swift.Bool)
    case string(Swift.String)
    case integer(Swift.Int)
    case decimal(Foundation.Decimal)
    case array([FlyBuyNotify.Token.Value])
    case dictionary([Swift.String : FlyBuyNotify.Token.Value])
    case range(Swift.ClosedRange<Swift.Int>)
    public var stringValue: Swift.String {
      get
    }
    public var decimalValue: Foundation.Decimal? {
      get
    }
    public var doubleValue: Swift.Double? {
      get
    }
    public var integerValue: Swift.Int? {
      get
    }
    public var isFalsy: Swift.Bool {
      get
    }
    public var isTruthy: Swift.Bool {
      get
    }
    public var isEmptyString: Swift.Bool {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: FlyBuyNotify.Token.Value, b: FlyBuyNotify.Token.Value) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol TokenValueConvertible {
  var tokenValue: FlyBuyNotify.Token.Value { get }
}
extension Swift.Dictionary : FlyBuyNotify.TokenValueConvertible where Key == Swift.String, Value == any FlyBuyNotify.TokenValueConvertible {
  public var tokenValue: FlyBuyNotify.Token.Value {
    get
  }
}
extension Swift.Array : FlyBuyNotify.TokenValueConvertible where Element : FlyBuyNotify.TokenValueConvertible {
  public var tokenValue: FlyBuyNotify.Token.Value {
    get
  }
}
extension Swift.Int : FlyBuyNotify.TokenValueConvertible {
  public var tokenValue: FlyBuyNotify.Token.Value {
    get
  }
}
extension Swift.String : FlyBuyNotify.TokenValueConvertible {
  public var tokenValue: FlyBuyNotify.Token.Value {
    get
  }
}
extension Swift.Float : FlyBuyNotify.TokenValueConvertible {
  public var tokenValue: FlyBuyNotify.Token.Value {
    get
  }
}
extension Swift.Double : FlyBuyNotify.TokenValueConvertible {
  public var tokenValue: FlyBuyNotify.Token.Value {
    get
  }
}
extension Swift.Bool : FlyBuyNotify.TokenValueConvertible {
  public var tokenValue: FlyBuyNotify.Token.Value {
    get
  }
}
extension Swift.Range : FlyBuyNotify.TokenValueConvertible where Bound : Swift.SignedInteger {
  public var tokenValue: FlyBuyNotify.Token.Value {
    get
  }
}
extension Swift.ClosedRange : FlyBuyNotify.TokenValueConvertible where Bound : Swift.SignedInteger {
  public var tokenValue: FlyBuyNotify.Token.Value {
    get
  }
}
extension Swift.String {
  public func firstIndex(reverse: Swift.Bool, where predicate: (Swift.Character) throws -> Swift.Bool) rethrows -> Swift.String.Index?
}
open class Filter {
  public init(identifier: Swift.String, lambda: @escaping (FlyBuyNotify.Token.Value, [FlyBuyNotify.Token.Value]) -> FlyBuyNotify.Token.Value)
  @objc deinit
}
extension FlyBuyNotify.Filter {
  public static func parseDate(string inputString: Swift.String) -> Foundation.Date?
}
open class Parser {
  public init(tokens: [FlyBuyNotify.Token], context: FlyBuyNotify.Context)
  open func registerFilters()
  open func registerTags()
  open func registerOperators()
  public func parse() -> [Swift.String]
  public func register(filter: FlyBuyNotify.Filter)
  public func register(operator: FlyBuyNotify.Operator)
  public func register(tag: FlyBuyNotify.Tag.Type)
  @_hasMissingDesignatedInitializers open class Scope {
    @objc deinit
  }
  public enum ParseErrors : Swift.Error {
    case malformedExpression(Swift.String)
    public var localizedDescription: Swift.String {
      get
    }
  }
  @objc deinit
}
public struct Lexer {
  public init(templateString: Swift.String)
  public func tokenize() -> [FlyBuyNotify.Token]
}
@_hasMissingDesignatedInitializers open class Operator {
  @objc deinit
}
public struct TemplateSyntaxError : Swift.Error, Swift.Equatable, Swift.CustomStringConvertible {
  public let description: Swift.String
  public init(_ description: Swift.String)
  public static func == (lhs: FlyBuyNotify.TemplateSyntaxError, rhs: FlyBuyNotify.TemplateSyntaxError) -> Swift.Bool
}
open class Tag {
  open class var keyword: Swift.String {
    get
  }
  open var tagExpression: [FlyBuyNotify.Tag.ExpressionSegment] {
    get
  }
  open var parameters: [Swift.String] {
    get
  }
  public var compiledExpression: [Swift.String : Any] {
    get
  }
  final public let context: FlyBuyNotify.Context
  open var definesScope: Swift.Bool {
    get
  }
  open var terminatesScopesWithTags: [FlyBuyNotify.Tag.Type]? {
    get
  }
  open var terminatesParentScope: Swift.Bool {
    get
  }
  open var tagKindsToSkip: Swift.Set<FlyBuyNotify.Tag.Kind>?
  open func didTerminate(scope: FlyBuyNotify.Parser.Scope, parser: FlyBuyNotify.Parser)
  open func didDefine(scope: FlyBuyNotify.Parser.Scope, parser: FlyBuyNotify.Parser)
  public var output: [FlyBuyNotify.Token.Value]?
  required public init(context: FlyBuyNotify.Context)
  open func parse(statement: Swift.String, using parser: FlyBuyNotify.Parser, currentScope: FlyBuyNotify.Parser.Scope) throws
  public enum ExpressionSegment {
    case literal(Swift.String)
    case identifier(Swift.String)
    case variable(Swift.String)
    case group(Swift.String)
  }
  public enum Errors : Swift.Error {
    case malformedStatement(Swift.String)
    case missingArtifacts
  }
  @objc deinit
}
extension FlyBuyNotify.Tag {
  public typealias Kind = Swift.Int
  public class var kind: FlyBuyNotify.Tag.Kind {
    get
  }
}
extension Swift.String {
  public struct HTMLEscapeOptions {
    public static var allowUnsafeSymbols: Swift.Bool
    public static var decimal: Swift.Bool
    public static var encodeEverything: Swift.Bool
    public static var useNamedReferences: Swift.Bool
  }
  public func htmlEscape(allowUnsafeSymbols: Swift.Bool = false, decimal: Swift.Bool = false, encodeEverything: Swift.Bool = false, useNamedReferences: Swift.Bool = false) -> Swift.String
  public func htmlUnescape(strict: Swift.Bool) throws -> Swift.String
  public func htmlUnescape() -> Swift.String
}
public enum ParseError : Swift.Error {
  case DeprecatedNumericReference(Swift.String)
  case DisallowedNumericReference(Swift.String)
  case IllegalArgument(Swift.String)
  case InvalidNamedReference(Swift.String)
  case MalformedNumericReference(Swift.String)
  case MissingSemicolon(Swift.String)
  case OutsideValidUnicodeRange(Swift.String)
}
@objc open class NotificationInfo : ObjectiveC.NSObject {
  @objc final public let title: Swift.String
  @objc final public let content: Swift.String
  @objc final public let data: [Swift.AnyHashable : Any]?
  @objc public init(title: Swift.String, content: Swift.String, data: [Swift.AnyHashable : Any]?)
  @objc deinit
}
extension Foundation.NSNotification.Name {
  public static let notifyCampaignsUpdated: Foundation.Notification.Name
  public static let notifyCampaignsError: Foundation.Notification.Name
  public static let notifySitesError: Foundation.Notification.Name
  public static let notifyNotificationsError: Foundation.Notification.Name
}
@_inheritsConvenienceInitializers @objc(FlyBuyNotifyManager) public class Manager : ObjectiveC.NSObject {
  @objc public static let shared: FlyBuyNotify.Manager
  final public let logger: FlyBuy.Logger
  public var lastSync: Foundation.Date? {
    get
  }
  @objc public func configure(bgTaskIdentifier: Swift.String? = nil, bgSyncCallback: (((any Swift.Error)?) -> Swift.Void)? = nil)
  @objc deinit
  @available(*, deprecated, message: "This method for using Notify has been deprecated.")
  @objc public func createForSitesInRegion(_ region: CoreLocation.CLCircularRegion, notification: FlyBuyNotify.NotificationInfo, callback: @escaping ([FlyBuy.Site]?, (any Swift.Error)?) -> Swift.Void)
  @available(*, deprecated, message: "This method for using Notify has been deprecated.")
  @objc public func createForSites(_ sites: [FlyBuy.Site], notification: FlyBuyNotify.NotificationInfo, callback: @escaping ((any Swift.Error)?) -> Swift.Void)
  @available(*, deprecated, message: "This method for using Notify has been deprecated.")
  @objc public func clear(callback: @escaping ((any Swift.Error)?) -> Swift.Void)
  @available(*, deprecated, message: "This method for using Notify has been deprecated.")
  @objc public func isFlyBuyNotifyUserInfo(_ userInfo: [Swift.AnyHashable : Any]) -> Swift.Bool
  @objc override dynamic public init()
}
extension FlyBuyNotify.Manager : FlyBuy.FlyBuyModuleManager {
  public func ordersUpdated(_ orders: [FlyBuy.Order])
  public func set(logLevel: FlyBuy.LogLevel)
  public func set(logWriteEnabled: Swift.Bool)
  public func configUpdated(_ config: FlyBuy.AppConfig, pushData: FlyBuy.PushData?)
}
@objc public enum NotifyErrorType : Swift.Int {
  case noLocationPermission
  case notificationPermissionDenied
  case reachedTheMaxNumberOfSites
  case notifyModuleNotConfigured
  case coreIsNotConfigured
  case notifyModuleNotEnabled
  case beaconRangingNotAvailable
  case noBeaconInRange
  case beaconRangingDisabledInBackground
  case failedToAddNotificationRequest
  public var description: Swift.String {
    get
  }
  public var string: Swift.String {
    get
  }
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc(FlyBuyNotifyError) public class NotifyError : ObjectiveC.NSObject, FlyBuy.FlyBuyError {
  @objc final public let type: FlyBuyNotify.NotifyErrorType
  @objc public init(_ typeIn: FlyBuyNotify.NotifyErrorType)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
}
extension FlyBuyNotify.Manager : FlyBuy.NotificationHandler {
  @objc dynamic public func sync(force: Swift.Bool = false, callback: (((any Swift.Error)?) -> Swift.Void)? = nil)
  @objc dynamic public func performFetchWithCompletionHandler(_ completionHandler: ((UIKit.UIBackgroundFetchResult) -> Swift.Void)? = nil)
  @available(*, deprecated, message: "This method for handling notification responses is deprecated. Use FlyBuy.Core.handleNotification(response:) instead")
  @objc dynamic public func handleNotification(_ response: UserNotifications.UNNotificationResponse) -> [Swift.String : Swift.String]?
  public func handle(response: UserNotifications.UNNotificationResponse) -> [Swift.String : Swift.String]?
}
extension FlyBuyNotify.Manager {
  public func updateCustomTemplateContent(_ content: [Swift.String : Swift.String])
}
extension FlyBuyNotify.NotifyErrorType : Swift.Equatable {}
extension FlyBuyNotify.NotifyErrorType : Swift.Hashable {}
extension FlyBuyNotify.NotifyErrorType : Swift.RawRepresentable {}
